# 第一章 绪论

## 数据结构的研究内容

早期, 计算机主要用于数值计算

首先，分析问题，提取操作对象。然后，找出操作对象之间的关系，用数学语言加以描述，建立相应的数学方程。最后，求解数学方程。

特点：数据元素间的关系简单，计算复杂

操作对象: 若干行数据记录

操作算法: 查询，插入，修改，删除

操作对象之间的关系：线性关系

文件系统的系统结构就是 数据与数据之间成一对多的关系, 是一种典型的非线性关系结构——树型结构

## 基本概念与术语

### 数据、数据元素、数据项和数据对象

#### 数据

-   是能输入计算机且能被计算机处理的各种符号的集合
    -   信息的载体
    -   是对客观事物符号化的表示
    -   能够被计算机识别、存储和加工
-   包括:
    -   数值型的数据: 整数、实数
    -   非数值型的数据: 文字、图像、图形、声音等

#### 数据元素

-   是数据的基本单位,在计算机程序中通常作为一个整体进行考虑和计算
-   也简称为元素,或称为记录、结点或顶点

#### 数据项

-   构成数据元素的不可分割的最小单位
-   数据、数据元素、数据项三者之间的关系:
    -   数据 > 数据元素 > 数据项

#### 数据对象

-   是性质相同的数据元素的结合,是数据的一个子集

#### 数据元素与数据对象

-   数据元素 —— 组成数据的基本单位
    -   与数据的关系: 是集合的个体
-   数据对象 ——性质相同的数据元素的集合
    -   与数据的关系: 集合的子集

### 数据结构(Data Structure)

-   数据元素不是孤立存在的,他们之间存在着某种关系,数据元素之间的关系称为结构
-   是指相互之间存在一种或多种特定关系的数据元素集合
-   或者说,数据结构是带结构的数据元素的集合

数据结构包括以下三个方面的内容:

1.   数据元素之间的逻辑关系,也称为逻辑结构
2.   数据元素及其关系在计算机内存中的表示,称为数据的物理结构或数据的存储结构
3.   数据的运算和实现,即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现

#### 逻辑结构

-   描述数据元素之间的逻辑关系
-   与数据的存储无关,独立于计算机
-   是从具体问题抽象出来的数学模型

#### 物理结构

-   数据元素及其关系在计算机存储器中的结构
-   是数据结构在计算机中的表示

#### 逻辑结构于存储结构的关系:

-   存储结构是逻辑关系的映像与元素本身的映像
-   逻辑结构是数据结构的抽象,存储结构是数据结构的实现
-   两者综合起来建立的数据元素之间的结构关系

#### 逻辑结构的种类

划分方式一

-   线性结构
    -   有且仅有一个开始和一个终端结点,并且所有结点都最多只有一个直接前趋和一个直接后继
    -   如: 线性表、栈、队列、串
-   非线性结构
    -   一个结点可能有多个直接前趋和直接后继

划分方式二 —— 四类基本逻辑结构

-   集合结构: 结构中的数据元素除了属于一个集合的关系外,无任何其他关系
-   线性结构: 结构中的数据元素之间存在一对一的线性关系
-   树型结构: 结构中的数据元素之间存在一对多的层次关系
-   图状结构或网状结构: 结构中的数据元素之间存在多对多的任意关系

四种基本的存储结构:

-   顺序存储结构
    -   用一组连续的存储单元依次存储数据元素,数据元素之间的逻辑关系由元素的存储位置来表示
    -   c语言中用数组来实现顺序存储结构
-   链式存储结构
    -   用一组任意的存储单元存储数据元素,数据元素之间的逻辑关系用指针来表示
    -   c语言中用指针来实现链式存储结构
-   索引存储结构
    -   在存储结点信息的同时,还建立附加的索引表
    -   索引表中的每一项称为一个索引项
    -   索引项的一般形式是: (关键字, 地址)
    -   关键字是能唯一标识一个结点的哪些数据项
    -   若每个结点在索引表中都有一个索引项,则该索引表称为**稠密索引**.若一组结点在索引表中只对应一个索引项,则该索引表称之为**稀疏索引**
-   散列存储结构
    -   根据结点的关键字直接计算出该结点的存储地址

### 数据类型和抽象数据类型

-   在使用高级程序设计语言编写程序时, 必须对程序中出现的每个变量,常量或表达式,明确说明他们所属的**数据类型**
    -   c语言中:
        -   提供int, char , float, double等基本数据类型
        -   数组, 结构, 共用体, 枚举等构造数据类型
        -   还有指针, 空(void) 类型
        -   用户也可以用typedef自己定义数据类型
-   高级语言中的数据类型明显地或隐含地规定了在程序执行期间变量和表达的所有可能的取值范围,以及在这些数值范围上允许进行的操作
    -   数据类型的作用:
        -   约束变量或常量的取值范围
        -   约束变量或常量的操作

#### 数据类型

-   数据类型就是一组性质相同的值的集合以及定义于这个值集合上的一组操作的总称
-   抽象数据类型就是一个数学模型以及定义在此数学模型上的一组操作
    -   由用户定义，从问题抽象出数据模型(逻辑结构)
    -   还包括定义在数据模型上的一组抽象运算（相关操作）
    -   不考虑计算机内的具体存储结构与运算的具体实现算法

#### 抽象数据类型的形式定义

一般指由用户定义的,表示应用问题的数学模型,以及定义在这个模型上的一组操作的总称, 具体包括三部分: 数据对象, 数据对象上关系的集合以及对数据对象的基本操作的集合

抽象数据类型可用 (D,S,P) 三元组表示

其中: D 是数据对象   S是D上的关系集  P是对D的基本操作集

基本操作定义格式说明:

参数表: 赋值参数 只为操作提供输入值

​	  引用参数 以&打头, 除可提供输入值, 还将返回操作结果

抽象数据类型定义格式:

```
ADT 抽象数据类型名{
	数据对象: <数据对象的定义>
	数据关系: <数据关系的定义>
	基本操作: <基本操作的定义>
} ADT 抽象数据类型名
```

### 总结

![image-20230219152822536](image-20230219152822536.png)

## 抽象数据类型的表示与实现

-   抽象数据类型可以通过固有的数据类型来表示和实现
    -   即利用处理器中已存在的数据类型来说明新的结构,用已经实现的操作来组合新的操作

## 算法和算法分析

-   算法的定义
    -   对特定问题求解方法和步骤的一种描述,它是指令的有限序列. 其中每个指令表示一个或多个操作
-   算法的描述
    -   自然语言
    -   流程图: 传统流程图, NS流程图
    -   伪代码: 类语言
    -   程序代码
-   算法与程序
    -   算法是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，
        一个问题可以有多种算法
    -   程序是用某种程序设计语言对算法的具体实现
-   算法特性
    -   有穷性: 一个算法必须总是在执行有穷步之后结束,且每一步都在有穷时间内完成
    -   确定性: 算法中的每一条指令必须有确切的含义，没有二义性，在任何条件
        下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。
    -   可行性: 算法是可执行的，算法描述的操作可以通过已经实现的基本操作执
        行有限次来实现。
    -   输入: 一个算法有零个或多个输入。
    -   输出: 一个算法有一个或多个输出。
-   算法设计的要求
    -   正确性: 算法满足问题要求,能正确解决问题
        1.   程序中不含语法错误
        2.   程序对于几组输入数据能够得出满足要求的结果
        3.   程序对于精心选择的、典型、苛刻且带有刁难性的机组输入数据能够得出满足要求的结果
        4.   程序对于一切合法的输入数据都能得出满足要求的结果
    -   可读性
        1.   算法主要是为了人的阅读和交流，其次才是为计算机
             执行，因此算法应该易于人的理解；
        2.   另一方面，晦涩难读的算法易于隐藏较多错误而难以
             调试。
    -   健壮性
        1.   指当输入非法数据时,算法恰当的做出反应或进行相应处理,而不是产生莫名的输出结果
        2.   处理出错的方法, 不应是中断程序的执行,而应是返回一个表示错误或错误性质的值,以便在更高的抽象层次上处理
    -   高效性
        1.   要求花费尽量少的时间和尽量低的存储需求

### 算法的优劣

-   一个个好的算法首先要具备正确性，然后是健壮性
    ,可读性，在几个方面都满足的情况下，主要考虑**算法的效率**，通过算法的效率高低来评判不同算法的优劣程度。
-   算法效率一下两个方面来考量
    1.   时间效率: 指的是算法所耗费的时间
    2.   空间效率: 指的是算法执行过程中所耗费的存储空间

-   算法时间效率的度量
    -   算法时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量
    -   两种度量方法
        -   事后统计
            -   讲算法实现,测算其时间和空间开销
            -   缺点: 编写程序实现算法将花费较多的时间和精力; 所得实验结果依赖于计算机的软硬件等环境因素,掩盖算法本身的优劣
        -   事前分析
            -   对算法所消耗资源的一种估算方法

#### 事前分析方法

-   个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的时间与算法中进行的简单操作次数乘积。
-   也即算法中每条语句的执行时间之和

算法运行时间 = 每条语句频度 * 该语句执行一次所需的时间

若有某个辅助函数f(),使得当n趋近于无穷夫时，/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)称O(f()为算法的渐进时间复杂度(O是数量级的符号)，简称时间复杂度。

-   最坏时间复杂度：指在最坏情况下，算法的时间复杂度。

-   平均时间复杂度：指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间。

-   最好时间复杂度：指在最好情况下，算法的时间复杂度。

-   空间复杂度: 算法所需存储空间的度量, 记作: S(n) = O(f(n)) 其中n为问题的规模

# 第二章 线性表

## 线性表的定义和特点

线性表是具有相同特性的数据元素的一个有限序列

线性表 (Linear List):  由n(n>= 0)个数据元素组成的有限序列

-   其中数据元素的个数n定义为表的长度
-   当n=0时称为空表
-   将非空的线性表(n>0)
-   这里的数据元素a(1≤i≤)只是一个抽象的符号，其具体含义在不同的情况下可以不同。

线性表的逻辑结构:

-   在非空的线性表，有且仅有一个开始结点1，它没有直接前趋，而仅有一个直接后继a2;
-   有且仅有一个终端结点an,'它没有直接后继，而仅有一个直接前趋an-1;
-   其余的内部结点a(2≤i≤n-1)都有且仅有一个直接前趋a:-和一个直接后继ai+1。 

顺序存储结构存在问题:

1.   存储空间分配不灵活
2.   运算的空间复杂度高

## 线性的类型定义

-   InitList

    -   操作结果: 构造一个空的线性表
-   DestroyList

    -   初始条件: 线性表已存在
    -   操作结果: 销毁线性表
-   ClearList

    -   初始条件: 线性表已存在
    -   操作结果: 将线性表重置为空表
-   ListEmpty

    -   初始条件: 线性表已存在
    -   操作结果: 若线性表为空表, 若返回True; 否则返回false
-   ListLength

    -   初始条件: 线性表已存在
    -   操作结果: 返回线性表中的数据元素个数
-   Get Elem
    -   初始条件: 线性表已存在
    -   操作结果: 用e返回线性表中第i个数据元素的值
-   LocateElem
    -   初始条件: 线性表已存在
    -   操作结果: 返回表中第一个与e满足compare()的数据元素的位序. 若这样的数据元素不存在则返回值为0
-   PriorElem(L, cur_e, & pre_e)
    -   初始条件: 线性表已存在
    -   操作结果: 若cur_e是 L的数据元素,且不是第一个, 则用pre_e返回它的前驱,否则操作失败,pre_e无意义
-   ListInsert(&L, i,e)
    -   初始条件: 线性表已存在, 1<= i<=ListLength(L)。
    -   操作结果: 在L的第i个位置之前插入新的数据元素e, L的长度加1
-   ListDelete(&L,i&e)
    -   初始条件: 线性表L已经存在 1<= i <=ListLength(L)。
    -   操作结果: 删除L的第i个元素,并且用e返回其的值,L的长度减一
-   ListTraverse(&L, visited())
    -   初始条件: 线性表已存在
    -   操作结果: 依次对线性表中的每个元素调用visited()

## 线性表的顺序表示和实现

定义: 把逻辑上相邻的数据元素存储在物理上相邻的存储单元的存储结构

### 线性表L的初始化

```c
Status InitList Sq(SqList &L){
    L.elem = new ElemType[MAXSIZE]
    if(!L.elem) {
        exit(OVERFLOW)
    }
    L.length = 0;
    return OK;
}
```

### 线性表的取值

```c
Status GetElem(SqList L, int i, ElemType &e){
    if(i<1 || i>L.length) {
        return ERROR;
    }
    e = L.elem[i-1];
    return OK;
}
```

### 线性表的查找

```c
int LocateElem(SqList L, ElemType e){
    for(i = 0; i<L.length;i++){
        if(L.elem[i]==e){
            return i+1;
        }
    }
    return 0;
}
```

### 线性表的插入

```c
Status ListInsert(SqList &L, int i, ElemType e)
{ // 在顺序表L中第i个位置插入新的元素e,i值的合法范围是 1<=i<= L.length()
	if ((i < 1) || (i > L.length + 1))
		return ERROR;
	if (L.length == MAXSIZE)
		return ERROR;
	for (j = L.length - 1; j >= i - 1; j--)
		L.elem[j + 1] = L.elem[j];
	L.elem[i - 1] = e;
	++L.length;
	return OK;
}
```

### 线性表的删除

````c
Status ListDelete_Sq(SqList &L, int i)
{
	if ((i < 1) || (i > L.length + 1))
		return ERROR;
	for (j = i; j <= L.length - 1; j++)
		L.elem[j - 1] = L.elem[j];
	L.length--;

	return OK;
}
````

优点: 

1.   存储密度大
2.   可以随机存取表中任一元素

缺点: 

1.   在插入,删除某一元素时,需要移动大量元素
2.   浪费存储空间
3.   属于静态存储形式,数据元素的个数不能自由扩充

## 线性表的链式表示和实现

特点: 

1.   用一组任意的存储单元存储线性表的数据元素 
2.   这组存储单元可以是连续的也可以是不连续的,甚至是零散分布在内存中的任意位置上的
3.   链表中元素的逻辑次序和物理次序不一定相同

两部分信息组成数据元素的存储映像称为结点

-   存储数据元素信息的域称为数据域
-   存储直接后继存储位置的域称为指针域 指针域中存储的信息称为指针或链

单链表、双链表、循环链表:

-   结点只有一个指针域的链表称为单链表或线性链表
-   结点应用两个指针域的链表,称为双链表

头指针、头结点和首元结点

-   头指针: 是指向链表中第一个结点的指针
-   首元结点: 是指链表中存储第一个数据元素a1的结点
-   无头结点,头指针为空时表示空表
-   有头结点,当头结点的指针域为空时表示空表

链表增加头结点的作用:

1.   便于首元结点处理
2.   便于非空表和空表的统一处理

### 链表的初始化

```c
int ListEmpty(LinkList L){
    if(L -> next){
        return 0;
    } else {
        return -1;
    }
}
```

### 销毁单链表

```c
Status DestroyList_L(LinkList &L){
    Lnode *p;
    while(L){
        P=L;
        L=L -> next;
        delete P;
    }
    return OK;
}
```

### 清空单链表

```c
Status ClearList(LinkList &L){
    Lnode *p, *q;
    p = L -> next;
    while(p){
        q = p.next;
        delete p;
        p = q;
    }
    L -> next = NULL;
    return OK;
}
```

### 求单链表的表长

```c
int ListLength_L(LinkList L){
    LinkList p;
    p = L -> next;
    i = 0;
    while(p){
        i++;
        p = p -> next;
    }
    return i;
}
```

### 单链表的取值

```c
Status GetElem(LinkList L, int i, ElemType &e){
    p = L -> next; j =1;
    while(p&&j<i){
        p = p -> next; ++j;
    }
    if(!p||j>i) return ERROR;
    e = p -> data;
    return OK;
}
```

### 单链表的查找

```c
// 返回元素地址
Lnode *LocateElem_L(LinkList L, ElemType e){
    p = L -> next;
    while(p && p -> data != e){
        p = o -> next;
    }
    return p;
}

// 返回元素位置序号
int LocateElem_L(LinkList L, ElemType e){
    p  = L -> next; j =1;
    while(p && p -> data!= e){
        p -> next; j++
    }
    if(p){
        return j;
    }else {
        return 0;
    }
}
```

### 单链表插入

[单链表插入](https://github.com/manneia/algorithm/blob/6d459d2d15bcec8dcb0370009f61659da2f8205d/src/com/luo/algorithm/study/CreateSingleLinkedList.java)

```c
Status ListInsert_L(LinkList &L,int i,ElemType e){
    p = L; j = 0;
    while(p && j < i-1){
        p = o -> next; ++j
    }
    if(!p || j> i - 1) return ERROR;
    s = new LNode; s -> data = e;
    s  -> next = p -> next;
   	p -> next = s;
    return OK;
}
```

### 单链表删除结点

```c
Status ListDelete_L(LinkList &L,int i,ElemType &e){
    p = L; j = 0;
    while(p -> next && j < i-1){
        p = p -> next; ++j;
    }
    if(!(p -> next) || j > i - 1) return ERROR;
    q = p -> next;
    p -> next = q -> next;
    e = q -> data
    delete q;
    return OK;
}
```



## 循环链表

是一种头尾相接的链表

### 将两个带有尾指针的循环链表合并

```c
LinkList Connect(LinkList Ta, LinkList Tb){
     p = Tb -> next;
     Ta -> next = Tb -> next -> next;
    delete Tb -> next;
    Tb = Ta -> next;
    return Tb;
}
```

## 双向循环链表

-   让头结点的前驱指针指向链表的最后一个结点
-   让最后一个结点的后继指针指向头结点。

### 双向链表的插入

```c
void ListInsert DuL(DuLinkList &L,Int i,ElemType e){
//在带头结点的双向循环链表L中第ⅰ个位置之前插入元素
	if(!(p=GetElemP DuL(L,i)))return ERROR;
		s=new DuLNode;    s->date e;
		s->prior p->prior;   p->prior ->next s;
		s ->next p;    p->prior s;
		return OK;
}
```

### 双向链表的删除

```c
void ListDelete_Dul(DuLink &L,int i, ElemType &e){
    if(!(p=GetElemP_Dul(L,i))) return ERROR;
    e = p -> data;
    p -> prior -> next = p -> next;
    p -> next -> prior = p -> prior;
    free(p);
    return OK;
}
```



## 顺序表和链表的比较

|                                 | 查找表头结点           | 查找表尾结点                             | 查找结点*p的前驱结点                              |
| ------------------------------- | ---------------------- | ---------------------------------------- | ------------------------------------------------- |
| 带头结点的单链表L               | L-> next时间复杂度O(1) | 从L->next依次向后遍历<br/>时间复杂度O(n) | 通过p->next无法找到其前驱<br/>                    |
| 带头结点仅设头指针L的循环单链表 | L-> next时间复杂度O(1) | 从L->next依次向后遍历<br/>时间复杂度O(n) | 通过p->next可以找到其前驱<br/>时间复杂度0(n)<br/> |
| 带头结点仅设尾指针R的循环单链表 | R-> next时间复杂度O(1) | R ->next <br/>时间复杂度0(1)             | 通过p->next可以找到其前驱<br/>时间复杂度O(n)<br/> |
| 带头结点的双向循环链表          | L-> next时间复杂度O(1) | L-> prior 时间复杂度O(1)                 | p->prior<br/>时间复杂度0(1)                       |

-   链式存储结构的优点: 
    -   结点空间可以动态申请和释放;
    -   数据元素的逻辑次序靠结点的指针来指示,插入和删除时不需要移动数据元素
-   链式存储结构的缺点:
    -   存储密度小,每个结点的指针域需要额外占用存储空间.当每个结点的数据域所占字节不多时,指针域所占存储空间的比重显得很大
    -   非随机存取结构. 对任一结点的操作都要从头指针依指针链查找到该结点，这增加了算法的复杂度。

![image-20230228174251351](image-20230228174251351.png)

## 线性表的应用

-   线性表的合并

```c
void union(List &La,List Lb){
	La_len = ListLength(La);
	Lb_len = ListLength(Lb);
	for(i = 1; i<= Lb_len; i++){
		GetElem(Lb_len,i,e);
		if(!LocateElem(La.e)) ListInsert(&La, ++La_len,e);
	}
}
```



-   有序表的合并

```c
void MergeList_Sq(SqList LA,SqList LB, SqList &LC){
    pa = LA.elem;
    pb = LB.elem;
		LC.length = LA.length + LB.length;
		LC.elem = new ELemType[LC.length];
		pc = LC.elem;
		pa_last = LA.elem + LA.length - 1;
		pb_last = LB.elem + LB.length - 1;
		while(pa <= pa_last && pb <= pb_last){
			if(*pa <= *pb) *pc ++ = *pa++;
			else *pc ++ = *pb++;
		}
		while(pa <= pa_last) *pc++=*pa++;
		while(pb <= pb_last) *pc++=*pb++;
}
```

链表实现

```c

void MergeList_L(LinkList &La, LinkList &Lb, LinkList &Lc)
{
	pa = La->next;
	pb = Lb->next;
	pc = Lc = La;
	while (pa && pb)
	{
		if (pa->data <= pb->data)
		{
			pc->next = pa;
			pc = pa;
			pa = pa->next;
		}
		else
		{
			pc->next = pb;
			pc = pb;
			pb = pb->next;
		}
	}
	pc->next = pa ? pa : pb;
}
```

# 第三章 栈和队列

栈和队列是两种常用的重要的数据结构

栈和队列是限定插入和删除只能在表的端点进行的线性表

由于栈的操作具有后进先出的固有特性,使得栈成为程序设计中的有用工具

由于队列的操作具有先进先出的特性,使得队列成为程序设计中解决类似排队问题的有用工具

## 栈的定义和特点

栈是一个特殊的线性表, 是限定仅在一端(进行插入和删除操作的线性表) 又称为 后进先出 (Last In First Out) 的线性表

表尾称为栈顶 TOP

表头称为栈底Base

插入元素到栈顶的操作,称为入栈 <=> PUSH

从栈顶删除最后一个元素的操作,称为出栈 <=> POP

### 栈和线性表的区别

一般线性表:

1.   逻辑结构: 一对一
2.   存储结构: 顺序表, 链表
3.   运算规则: 随机存取

栈: 

1.   逻辑结构: 一对一
2.   存储规则: 顺序栈, 链栈
3.   运算规则: 后进先出

### 顺序栈的实现

存储方式: 同一般线性表的顺序存储结构完全相同

top指针, 指示栈顶元素在顺序栈的位置

base指针, 指示栈底元素在顺序栈的位置

stacksize 表示 栈可使用的最大容量

base == top 是栈空的标志

top - base == stacksize 是栈满的标志

栈满的处理方法:

1.   报错, 返回操作系统
2.   分配更大的空间, 作为栈的存储空间, 将原栈的内容移入新栈

### 连栈的表示和实现

链栈是运算受限的单链表, 只能在链表头部进行操作

### 栈与递归

递归: 若一个对象部分地包含它自己, 或用它自己给自己定义, 则称这个对象是递归的

若一个过程直接地或间接地调用自己,则称这个过程是递归的过程

递归问题——用分治法求解

1.   能将一个问题转变成一个新问题, 而新问题与原问题的解法相同或类似, 不同的仅是处理的对象,而这些处理对象是变化有规律的
2.   可以通过上述转话而使问题简化
3.   必须有一个明确的递归出口,或称递归的边界

递归的优缺点:

优点: 结构清晰, 程序易读

缺点: 每次调用要生成工作记录, 保存状态信息, 入栈; 返回时, 要出栈,恢复状态信息. 时间开销大

方法1: 尾递归, 单向递归

方法2: 自用栈模拟系统的运行时栈

## 队列的定义和特点

队列是一种先进先出的线性表. 在表的一端插入, 在另一端删除. 

### 队列的表示和操作的实现

队列是仅在表尾进行插入操作, 在表头进行删除操作的线性表

表尾即an端, 称为队尾, 表头即a1端,称为队头

是一种先进先出的线性表

# 第四章 串、数组和广义表

## 串

串 ——零个或多个任意字符组成的有限序列

子串 ——一个串中任意个连续字符组成的子序列(含空串)称为该串的子串

真子串是指不包含自身的所有子串

![image-20230311123714161](image-20230311123714161.png)

串相等: 当且仅当两个串的长度相等并且各个对应位置上的字符都相同时,这两个串才是相等的

## 串的模式匹配算法

算法目的: 确定主串中所含子串第一次出现的位置

算法应用: 搜索引擎, 拼写检查, 语言翻译, 数据压缩

算法种类: 

-   BF算法
-   KMP算法

## 数组

数组: 按一定格式排列起来的, 具有相同类型的数据元素的集合

一维数组: 若线性表中的数据元素为非结构的简单元素,则称为一维数组

一维数组的逻辑结构: 线性结构

## 数组的顺序存储

数组特点: 结构不变——维数和维界不变

数组基本操作: 初始化,销毁,取元素,修改元素值.一般不做插入和删除操作

存储单元是一维结构, 而数组是个多维结构,则用一组连续存储单元存放数组的数据元素就有个次序约定问题

### 特殊矩阵的压缩存储

#### 什么是压缩存储?

若多个数据元素的值都相同, 则只分配一个元素值的存储空间,且零元素不占存储空间

#### 什么样的矩阵能够压缩?

一些特殊矩阵, 如: 对称矩阵, 对角矩阵, 三角矩阵, 稀疏矩阵

#### 什么叫稀疏矩阵? 

矩阵中非零元素的个数较少

## 广义表

广义表又称为Lists 是n >= 0 个元素的有限序列, 其中每一个元素或者是原子, 或者是一个广义表

广义表的表头和表尾是广义表的两个重要部分，它们可以唯一确定一个广义表。当广义表非空时，称第一个元素为表头；称广义表中除去表头后其余元素组成的广义表为表尾

1.   广义表中的数据元素有相对次序; 一个直接前去和一个直接后继
2.   广义表的长度定义为最外层包含的元素的个数
3.   广义表的深度定义为该广义表展开后所含括号的重数
4.   广义表可以为其他广义表共享;

### 广义表和线性表的区别

广义表可以看成是线性表的推广，线性表是广义表的特例。

广义表的结构相当炱活，在某种前提下，它可以兼容线性表、数组、
树和有向图等各种常用的数据结构。

当二维数组的每行（或每列）作为子表处理时，二维数组即为一个厂
义表。

另外，树和有向图也可以用广义表来表示。

由于广义表不仅集中了线性表、数组、树和有向图等常见数据结构的
特点，而且可有效地利用存储空间，因此在计算机的许多应用领域都有成
功使用广义表的实例。

### 广义表的基本运算

1.   求广义表的表头 : 非空广义表的第一个元素, 可以是第一个原子, 也可以是一个子表
2.   求广义表的表尾 : 非空广义表除去表头元素以外的其他元素所构成的表尾, 表尾一定是一个表

# 第五章 树与二叉树

## 树和二叉树的定义

-   树是 n (n >= 0) 个结点的有限集
    -   若n = 0, 则称为空树;
    -   若n > 0 则它满足如下两个条件: 
        -   有且仅有一个特定的称为根的结点
        -   其余结点可分为 m (m >= 0) 个互不相交的有限集, 其中每一个集合本身又是一个树, 并称为根的子树

二叉树

是n (n >= 0) 个结点的有限集, 它或者是空集(n = 0), 或者由一个根结点及两棵互不相交的分别称为这个根的左子树和右子树的二叉树组成

1.   每个结点最多有俩孩子
2.   子树有左右之分,其次序不难颠倒
3.   二叉树可以是空集合, 根可以有空的左子树或空的右子树

二叉树不是树的特殊情况.

### 树的基本术语

根结点 : 非空树种无前驱结点的结点

森林: 是m棵树互不相交的树的集合

一棵树可以看成一个特殊的森林



### 二叉树的性质和存储结构

1.   在二叉树的第 i 层上至多有`Math.pow(2,i - 1)` 个结点.  至少有 `1` 个结点

2.   深度为 k 的 二叉树 至多有 `Math.pow(2,k) - 1` 个结点. 最少 有 `k` 个结点

3.   对任何一棵二叉树 T , 如果其叶子数为 `n0`, 度为 2 的结点数为 `n2`, 则 `n0 = n2 + 1`

     

两种特殊形式的二叉树

-   满二叉树
    -   一棵深度为 k , 且有 `Math.pow(2,k) - 1` 个结点的二叉树称为满二叉树
-   完全二叉树
    -   深度为 k 的具有 n 个结点的二叉树,当且仅当其每一个结点都与深度为k 的满二叉树 中编号为 1 ~ n  的结点 一一对应时, 称为完全二叉树
    -   注: 在满二叉树中,从最后一个结点开始, 连续去掉任意个结点, 即是一颗完全二叉树
        -   叶子只可能分布在层次最大的两层
        -   对任一结点, 如果其右子树的最大层次为i, 则其左子树的最大层次必为 i 或 i + 1

4.   具有 n 个 结点的 完全 二叉树的深度为`log2 n + 1`
5.   如果对一棵树 有 n 个结点的完全二叉树,则对任一结点i 有:
     1.   如果 i = 1, 则结点 i 是二叉树的根, 无双亲; 如果 i > 1, 则其双亲是结点[i / 2]
     2.   如果 2i > n ,则结点 i为叶子结点, 无左孩子; 否则其左孩子是结点 2i
     3.   如果 2i + 1 > n , 则结点无右孩子,否则, 其右孩子是结点 2i + 1

## 二叉树的存储结构

### 二叉树的顺序存储

实现: 按满二叉树的结点层次编号, 依次存放二叉树中的数据元素

缺点: 

1.   大小固定 结点间关系蕴含在其存储位置中, 浪费空间, 适用于存满二叉树和完全二叉树

### 二叉树的链式存储

在n个结点的二叉链表中, 有 `n+ 1` 个空指针域

## 遍历二叉树

-   遍历定义—— 顺着某一条搜索路径巡访二叉树中的结点,使得每个结点均被访问依次, 而且仅一次
-   遍历目的——得到树中所有结点的一个线性排列
-   遍历用途——它是树结构插入,删除,修改,查找和排序运算的前提,是二叉树一切运算的基础和核心

若规定先左后右, 则只有三种情况: 

-   DLR ——先根序遍历

```c
void preOrderTraverse(BiTree T)
{
	if (T == NULL)
	{
		return;
	}
	printf("%d", T->data);
	preOrderTraverse(T->left);
	preOrderTraverse(T->right);
}
```



```java
public void preorderTraversal(TreeNode node) {
    if (node != null) {
        System.out.print(node.val + " ");
        preorderTraversal(node.left);
        preorderTraversal(node.right);
    }
}
```

-   LDR—— 中根序遍历
-   LRD—— 后根序遍历

![image-20230404195113228](image-20230404195113228.png)

若二叉树中各结点的值均不相同,则二叉树结点的先序序列, 中序序列和后序序列都是唯一的.

由二叉树的先序序列和中序序列,或后序序列和中序序列可以确定唯一一棵二叉树

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
}

private TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {
    if (preStart > preEnd || inStart > inEnd) {
        return null;
    }
    int rootVal = preorder[preStart];
    int index = 0;
    for (int i = inStart; i <= inEnd; i++) {
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }
    TreeNode root = new TreeNode(rootVal);
    int leftSize = index - inStart;
    root.left = buildTree(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1);
    root.right = buildTree(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd);
    return root;
}
```

二叉树的层次遍历

```c
void LevelOrder(BTNode *T)
{
	BTNode *p;
	SqQueue *qu;
	initQuene(qu);
	EnQuene(qu, T);
	while (!QueueEmpty(*qu))
	{
		DeQueue(qu, p);
		printf("%c", p->data);
		if (p->lchild != NULL)
		{
			EnQuene(qu, p->lchild);
		}
		if (p->rchild != NULL)
		{
			EnQuene(qu, p->rchild);
		}
	}
}
```

按照先序遍历序列建立二叉树

1. 从键盘输入二叉树的结点信息,建立二叉树的存储结构
2. 在建立二叉树的过程中按照二叉树先序方式建立
```c
Status CreateBiTree(BiTree &T) {
	scanf(&ch);
	if(ch == "#") {
		T = NULL;
	} else {
		if(!(T = (BiTNode *)malloc(sizeof(BiTNode)))){
			exit(OVERFLOW);
		}
		T -> data = ch;
		CreateBiTree(T -> lchild);
		CreateBiTree(T -> rchild);
	}
	return OK;
}
```
复制二叉树
1. 如果是空树,递归结束
2. 否则,申请新结点空间,复制根结点
    1. 递归复制左子树
    2. 递归复制右子树

```c
int Copy(BiTree T, BiTree &NewT){
	if(T == NULL) {
		NewT = NULL;
	} else {
		NewT = new BiTNode;
		NewT->data = T->data;
		Copy(T->lChild,NewT->lChild);
		Copy(T->rChild,NewT->rChild);
	}
}
```
计算二叉树的叶子结点数
1. 如果是空树, 则叶子结点数为0
2. 否则,为左子树的叶子结点个数 + 右子树的叶子结点个数
```c
int LeafCount(BiTree T) {
	if(T == NULL) {
		return 0;
	}
	if(T -> lChild == NULL && T -> rChild == NULL) {
		return 1;
	} else {
		return LeafCount(T -> lChild) + LeafCount(T -> rChild)
	}
}
```
计算二叉树的深度
1. 如果是空树,则深度为0
2. 否则,递归计算左子树的深度,记为m,递归计算右子树的深度,记为n. 二叉树的深度则为m与n的较大值加1
```c
int Depth(BiTree T){
	if(T == NULL) {
		return 0;
	} else {
		m = Depth(T->lChild);
		n = Depth(T->rChild);
		if(m > n) {
			return m + 1;
		} else {
			return n + 1;
		}
	}
}
```

## 线索二叉树

利用二叉链表中的空指针域:

​		如果某个结点的左孩子为空,则将空的左孩子指针域改为指向其前驱;右孩子同理.

这种改变指向的指针称为“线索”

## 树 和 森林

树是n`(n>=0)`个结点的有限集. 若n = 0 ,称为空树;
若n > 0 
     (1) 有且仅有一个特定的称为根的结点
     (2) 其余结点可分为 m个互不相交的有限集
森林: m棵互不相交的树的集合

### 树的存储结构

1. 双亲表示法

    -   实现: 定义结构数组, 存放树的结点, 每个结点包含两个域
        -   数据域: 存放结点本身信息
        -   双亲域: 指示本结点的双亲结点在数组中的位置

    特点: 找双亲容易, 找孩子难

2. 孩子链表

    -   把每个结点的孩子结点排列起来,看成一个线性表,用单链表存储,则n个结点有n个孩子链表. 而n个头指针又组成一个线性表,用顺序表存储

3. 孩子兄弟表示法 (二叉树表示法, 二叉链表表示法)

    -   用二叉链表作树的存储结构,链表中每个结点的两个指针域,分别指向其第一个孩子结点和下一个兄弟结点

### 树与森林的运算

#### 二叉树和 森林之间的转换

1.   将树转换成二叉树 (兄弟相连留长子) 
     1.   加线: 在兄弟之间加一连线
     2.   抹线: 对每个结点, 除了其左孩子,去除其与其余孩子之间的关系
     3.   旋转: 以树的根节点为轴心,将整树顺时针旋转45度

2.   将二叉树转换成树
     1.   加线: 若p结点是双亲结点的左孩子, 则将p的右孩子, 以及它的右孩子都与p的双亲用线连起来
     2.   抹线: 抹掉原二叉树中双亲与右孩子之间的连线
     3.   调整: 将结点按层次排列

3.   森林转换成二叉树
     1.   将各棵树分别转换成二叉树
     2.   将每棵树的根结点用线相连
     3.   以第一棵树根节点为二叉树的根,在以根结点为轴心,顺时针旋转,构成二叉树型结构
4.   二叉树转换成森林
     1.   抹线: 将二叉树中根节点与其右孩子连线,以及沿右分支搜索到的所有右孩子间连线全部抹掉, 使之变成独立的二叉树
     2.   还原: 将孤立的二叉树还原成树

#### 树的遍历

-   先根遍历: 
    -   若树不空, 则先访问根结点,然后依次先根遍历各棵子树
-   后根遍历: 
    -   若树不空，则先依次后根遍历各棵子树，然后访问根结点。
-   按层次遍历:
    -   若树不空，则自上而下自左至右访问树中每个结点。

## 哈夫曼树

路径: 从树中一个结点到另一个结点之间的分支构成这两个结点间的路径.

结点的路径长度: 两结点间路径上的分支数

树的路径长度: 从树根到每一个结点的路径长度之和

权: 将树中结点赋给一个有着某种含义的数值,则这个数值称为该结点的权

哈夫曼树: 最优树, 带权路径长度最短的树 最优二叉树, 带权路径长度最短的二叉树

“带权路径长度最短”是在“度相同”的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。

哈夫曼树中权越大的叶子离根越近

### 哈夫曼树的构造算法

#### 哈夫曼算法

1.   根据n个给定的权值,构成n棵二叉树的森林
     F={T1,T2,T3,…,Tn},其中T只有一个带权为wi的根结点。

-   构造森林全是根

2.   (2)在)F中选取两棵根结点的权值最以的树作为左右子树，构造一棵新的
     二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值
     之和。

-   选用两小造新树

3.   在F中删除这两棵树，同时将新得到的二叉树加入森林中。

-   删除两小添新人

4.   重复 2 和 3 直到森林中只有一棵树为止,这棵树即为哈夫曼树

实现

```c++
1. 树的结点类型定义
typedef struct
{
	int weight;
	int parent, lch, rch;
} HTNode, *HuffmanTree;

```

```c++

void CreateHuffmanTree(HuffmanTree &HT, int n)
{
	if (n <= 1)
	{
		return;
	}
	int m = 2 * n - 1;
	HT = new HTNode[m + 1];
	for (int i = 1; i < m; ++i)
	{
		HT[i].parent = 0;
		HT[i].lChild = 0;
		HT[i].rChild = 0;
	}
	for (int i = 1; i <= n; ++i)
	{
		cin >> HT[i].weight
	}
	for (int i = n + 1; i <= m; ++i)
	{
		Select(HT, i - 1, s1, s2);
		HT[s1].parent = i;
		HT[s2].parent = i;
		HT[i].lChild = s1;
		HT[i].rChild = s2;
		HT[i].weight = HT[s1].weight + HT[s2].weight;
	}
}
```

### 哈夫曼编码

问题 : 什么样的前缀编码能使得电文总长最短 ——哈夫曼编码

1.   统计字符集中每个字符在电文中出现的平均概率(概率越大,要求编码越短)
2.   利用哈夫曼树的特点: 权越大的叶子离根越近,将每个字符的概率值作为权值,构造哈夫曼树.则概率越大的结点,路径越短
3.   在哈夫曼树的每个分支上标注0或1;
     1.   结点的左分支标注0,右分支标注1
     2.   把从根到每个叶子的路径上的标号连接起来,作为该叶子代表的字符的编码

##### 为什么哈夫曼编码能够保证是前缀编码?

因为没有一片树叶是另一片树叶的祖先,所以每个叶结点的编码不可能是其他叶结点编码的前缀

##### 为什么哈夫曼编码能够保证字符编码总长最短?

因为哈夫曼树的带权路径长度最短,故字符编码的总长最短

构建哈夫曼编码的算法

```c++
void CreateHuffmanCode(HuffmanTree HT, int n, HuffmanCode &HC)
{
	HC = new char *[n + 1];
	cd = new char[n];
	cd[n - 1] = '\0';
	for (int i = 1; i <= n; ++i)
	{
		int start = n - 1;
		int c = i; // current character.
		f = HT[i].parent;
		while (f != 0)
		{
			--start;
			if (HT[f].lChild == c)
			{
				cd[start] = '0';
			}
			else
			{
				cd[start] = '1';
			}
			c = f;
			f = HT[f].parent;
		}
		HC[i] = new char[n - start];
		strcpy(HC[i], &cd[start]);
	}
	delete cd;
}
```

# 第六章 图

## 6.1 图的定义和基本术语

图 : G = (V,E)

​	V: 顶点的有穷非空集合

​	E: 边的有穷集合

无向图: 每条边都是无方向的

有向图: 每条边都是有方向的

完全图: 任意两个点都有一条边相连

稀疏图: 有很少边或弧的图

稠密图: 有较多边或弧的图

权: 图中边或弧所具有的相关数称为权. 表明从一个顶点到另一个顶点的距离或耗费

网: 边/弧带权的图

邻接: 有边/弧相连的两个顶点之间的关系. 存在(vi,vj) 则称他们互为邻接点. 存在<vi,vj> 则称vi邻接到vj,vj邻接于vi

关联: 边/弧与顶点之间的关系

顶点的度: 与该顶点相关联的边的数目

路径: 接续的边构成的顶点序列

路径长度: 路径上边或弧的数目/权值之和

回路: 第一个顶点和最后一个顶点相同的路径

简单路径: 除路径七点和终点可以相同外,其余顶点均不相同的路径

简单回路: 除路径七点和终点相同外,其余顶点均不相同的路径

连通图(强连通图): 在无(有) 向图G = (V,{E})中, 若对任何两个顶点v, u都存在从v到u的路径, 则称G是连通图(强连通图)

子图: 设有两个图 G = (V,{E}), G1 = (V1,{E1}), 若 V 包含 V1 , E 包含 E1 则 G1 是 G的子图

连通分量: 无向图G 的 极大连通子图称为G的连通分量

极大连通子图：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通

极小连通子图：该子图是G连通子图，将该子图中删除任何一个，子图不再连通

生成树: 包含无向图G 所有顶点的极小连通子图

生成森林: 对非连通图, 由各个连通分量的生成树的集合

## 6.2 图的类型定义

```c++
const int MAXN = 100;
int g[MAXN][MAXN];

int n;

void add_edge(int u, int v, int w)
{
	g[u][v] = w;
	g[v][u] = w;
}
```

## 6.3 图的存储结构

### 数组表示法 (邻接矩阵)

```c++

#define MaxInt 32767
#define MVNum 100 // 最大顶点数
typedef char VerTexType; // 设顶点的数据类型为字符型
typedef int ArcType; // 假设边的权值类型为整型
typedef struct
{
	VerTexType vexs[MVNum]; //顶点表
	ArcType arcs[MVNum][MVNum]; // 邻接矩阵
	int vexnum, arcnum; // 图的当前点数和边数
} AMGraph;


```

```c++
1. 输入总顶点数和总边数
2. 依次输入点的信息存入顶点表中
3. 初始化邻接矩阵,使每个权值初始化为极大值
4. 构造邻接矩阵

Status CreateUDN(AMGraph &G) {
    cin >> G.vexnum >> G.arcnum; // 输入总顶点数和边数
    for(i = 0; i < G.vexnum; ++i)
        // 依次输入点的信息
        cin >> G.vexs[i];
    // 初始化邻接矩阵
    for(i = 0; i < G.vexnum; ++i)
        for(j = 0; j < G.vexnum; ++j)
            // 边的权值均置为极大值
            G.arcsp[i][j] = MaxInt;
    // 构造邻接矩阵
    for(k = 0; k < G.arcnum; ++k) {
        // 输入一条边所依附的顶点及边的权值
        cin>>v1>>v2>>w;
    	i = LocateVex(G,v1);
    	j = LocateVex(G,v2);
    	G.arcs[i][j] = w;
    	G.arcs[j][i] = G.arcs[i][j];
    }
    return OK;
}    

```



### 链表表示法 (邻接表)

-   顶点: 
    -   按照编号顺序将顶点数据存储在一维数组中;
-   关联同一顶点的边
    -   用线性链表存储
-   特点: 
    -   邻接表不唯一
    -   若无向图中有n个顶点.e条边,则其邻接表需要n个头结点和2e个表结点.适宜存储稀疏图

![image-20230503184441873](image-20230503184441873.png)

```c++
typedef struct ArcNode
{
	int adjvex;
	struct ArcNode *nextarc;
	OtherInfo info;
} ArcNode;

typedef struct VNode
{
	VerTexType data;
	ArcNode *firstarc;
} VNode, AdjList[MVNum];

typedef struct
{
	AdjList vertices;
	int vexnum, arcnum;
} ALGraph;
```

### 邻接矩阵与邻接表的关系

区别: 

1.   对于任一确定的无向图,邻接矩阵是唯一的,但是邻接表不唯一
2.   邻接矩阵的空间复杂度为O(n2),邻接表的时间复杂度为O(n+e)
3.   用途: 邻接矩阵多用于稠密图;而邻接表多用于稀疏图

![image-20230504173330605](image-20230504173330605.png)

## 6.4 图的遍历

定义: 从已给的连通图中某一顶点出发,沿着一些边访遍图中所有的顶点,且每个顶点仅被访问一次, 就是图的遍历,它是图的基本运算

常用的遍历: 

-   深度优先搜索 (DFS)

```c++
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

const int MAXN = 1000;
vector<int> graph[MAXN]; // 图的邻接表表示
bool visited[MAXN];			 // 标记数组

// 深度优先搜索 DFS
void dfs(int u)
{
	visited[u] = true; // 标记节点u已访问
	cout << u << " ";	 // 输出节点u
	for (int i = 0; i < graph[u].size(); i++)
	{
		int v = graph[u][i];
		if (!visited[v])
		{					// 如果节点v没有访问过
			dfs(v); // 递归访问节点v
		}
	}
}
```

-   广度优先搜索 (BFS)

```c++
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

const int MAXN = 1000;
vector<int> graph[MAXN]; // 图的邻接表表示
bool visited[MAXN];			 // 标记数组

// 广度优先搜索 BFS (Breadth-First Search, BFS)

void bfs(int s)
{
	queue<int> q;
	q.push(s);				 // 把起点s加入队列
	visited[s] = true; // 标记节点s已访问
	while (!q.empty())
	{
		int u = q.front(); // 取出队首元素
		q.pop();
		cout << u << " "; // 输出节点u
		for (int i = 0; i < graph[u].size(); i++)
		{
			int v = graph[u][i];
			if (!visited[v])
			{										 // 如果节点v没有访问过
				visited[v] = true; // 标记节点v已访问
				q.push(v);				 // 把节点v加入队列
			}
		}
	}
}
```

## 6.5 图的应用

